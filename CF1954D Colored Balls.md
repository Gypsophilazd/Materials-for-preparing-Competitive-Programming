## 题目描述

有 $n$ 种不同颜色的球，第 $i$ 种颜色的球有 $a_i$ 个。

这些球可以被组合成若干组。每组最多包含 $2$ 个球，并且每组中每种颜色的球最多只能有 $1$ 个。

考虑所有 $2^n$ 种颜色集合。对于某个颜色集合，定义其值为用这些颜色的球能分成的最少组数。例如，若有三种颜色，球的数量分别为 $3$、$1$ 和 $7$，则这些球最少能组合成 $7$ 组（且不能更少），所以该颜色集合的值为 $7$。

你的任务是计算所有 $2^n$ 种颜色集合的值之和。由于答案可能很大，请输出其对 $998\,244\,353$ 取模的结果。

## 输入格式

第一行包含一个整数 $n$（$1 \le n \le 5000$），表示颜色的数量。

第二行包含 $n$ 个整数 $a_1, a_2, \dots, a_n$（$1 \le a_i \le 5000$），表示第 $i$ 种颜色的球的数量。

输入的额外限制：所有球的总数不超过 $5000$。

## 输出格式

输出一个整数，表示所有 $2^n$ 种颜色集合的值之和，对 $998\,244\,353$ 取模。

## 输入输出样例 #1

### 输入 #1

```
3
1 1 2
```

### 输出 #1

```
11
```

## 输入输出样例 #2

### 输入 #2

```
1
5
```

### 输出 #2

```
5
```

## 输入输出样例 #3

### 输入 #3

```
4
1 3 3 7
```

### 输出 #3

```
76
```

## 说明/提示

考虑第一个样例。共有 $8$ 个颜色集合：

- 空集，值为 $0$；
- 集合 $\{1\}$，值为 $1$；
- 集合 $\{2\}$，值为 $1$；
- 集合 $\{3\}$，值为 $2$；
- 集合 $\{1,2\}$，值为 $1$；
- 集合 $\{1,3\}$，值为 $2$；
- 集合 $\{2,3\}$，值为 $2$；
- 集合 $\{1,2,3\}$，值为 $2$。

因此，所有 $2^n$ 种颜色集合的值之和为 $11$。

## Solution

题意比较复杂，先分析一下题意。核心是计算一个给定颜色集合的“值”，也就是把这些颜色的所有球分成组，所需要的最少组数是多少。规则：
1. 每组最多 2 个球。
2. 同一种颜色的球不能在同一组。

我们来分析一下这两个规则意味着什么。假设我们选定了一个颜色集合，其中各种颜色球的数量分别是 $c_1, c_2, \dots, c_k$。

- 令球的总数 $S = \sum c_i$。

- 令数量最多的那种球有 $M = \max(c_1, c_2, \dots, c_k)$ 个。

现在我们想求最少组数 $G$。有两个限制条件决定了 $G$ 的下限：

1. **数量最多的球的限制**：那 $M$ 个同一颜色的球，每一个都必须分到不同的组里去。所以，我们至少需要 $M$ 个组。因此，$G \ge M$。
 
2. **球的总数限制**：总共有 $S$ 个球，每个组最多放 2 个。那么为了装下所有的球，我们至少需要 $\lceil S/2 \rceil$ 个组（$S/2$ 向上取整）。因此，$G \ge \lceil S/2 \rceil$。

综合这两个条件，最少的组数 G 必须同时满足它们，所以 G 必须大于等于它们中的较大者。

$$G \ge \max(M, \lceil S/2 \rceil)$$

事实上，这个下限总可以达到。我们可以这样构造：先拿出 $M$ 个组，把数量最多的那种颜色的球放进去。然后把剩下的 $S−M$ 个球尽量塞进这 M 个组的空位里。如果有多余的球，再两两配对开新的组。可以证明，最终的组数恰好就是 $\max(M,⌈S/2⌉)$。

**所以，一个颜色集合的“值”就是 $\max(\text{该集合中数量最多的球数}, \lceil \text{该集合中球的总数}/2 \rceil)$。**

例如，样例中 `{3, 1, 7}`：
- $M = \max(3, 1, 7) = 7$， $S = 3 + 1 + 7 = 11$
- $\lceil S/2 \rceil = \lceil 11/2 \rceil = 6$
- 值为 $\max(7, 6) = 7$。
---

我们的任务是计算所有 $2^n$ 个颜色集合的“值”的总和。直接枚举 $2^n$ 个集合是行不通的（$n$ 最大为 $5000$）。这提示我们要用动态规划。找到一个合适的顺序来处理问题，避免重复计算。

1. **排序**：先把所有颜色的球数 $a_i$ 从小到大排序。这是一个非常关键的步骤，它让我们可以方便地确定一个集合中的最大值。

2. **按最大值分类**：我们不直接枚举集合，而是枚举每个集合的**最大元素**是什么。当我们考虑 $a_i$ 时，我们就计算所有“以 $a_i$ 为最大球数的颜色集合”的贡献。

一个集合以 $a_i$ 为最大值，意味着这个集合必须包含第 $i$ 种颜色，且其他所有颜色都必须从前 $i-1$ 种（那些球数小于等于 $a_i$ 的颜色）中挑选。

**设 $dp[k]$ 表示：只从前 $i-1$ 种颜色中挑选，组成一个子集，这些子集中球的总数为 $k$ 的方案数。**

我们从 $i=1$ 到 $n$ 遍历每一种颜色 $a_i​$。在处理 $a_i$​ 时：

1. **计算贡献**：此时的 `dp` 数组是基于前 $i-1$ 种颜色得到的。我们要计算所有以 $a_i$ 为最大值的集合的贡献。任意选取一个由前 $i-1$ 种颜色组成的集合，假设其球总数为 $j$。这样的集合有 `dp[j]` 个。
   
2. 现在我们把 $a_i$ 加入这个集合。新集合的最大值 $M = a_i$，总数 $S = j + a_i$。根据第一步的公式，这个新集合的值为 $\max(a_i, \lceil (j + a_i)/2 \rceil)$。

这里需要分情况讨论：

**情况 A**: 如果 $a_i \ge \lceil (j + a_i)/2 \rceil$。这个不等式化简后得到 $2a_i \ge j+a_i$，即 $j \le a_i$。此时，值为 $a_i$。

**情况 B**: 如果 $a_i < \lceil (j + a_i)/2 \rceil$。这等价于 $j > a_i$。此时，值为 $\lceil (j + a_i)/2 \rceil$。向上取整可以写成 `(j + a[i] + 1) / 2`。

所以，对于每个可能的 `j`，我们把 `dp[j] * a[i]` 累加到最终答案 `ans` 中。

3. **更新 DP 数组**：计算完 $a_i$ 的贡献后，我们需要更新 `f` 数组，把 $a_i$ 也考虑进来，为计算下一个 $a_{i+1}$ 做准备。更新后的 `dp_new[k]` 应该表示从前 `i` 种颜色中挑选，球总数为 `k` 的方案数。对于一个总数为 $k$ 的集合，它要么不包含 $a_i$（方案数来自原来的 `dp[k]`），要么包含 $a_i$（方案数来自原来的 `dp[k - a[i]]`）。

所以更新方程是：`dp_new[k] = f[k] + f[k - a[i]]`。 这是一个典型的 0/1 背包问题。为了节省空间，我们可以用一个一维数组原地更新，但需要**从后往前**遍历 `k`，以保证 `dp[k - a[i]]` 还是旧的值。

## Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e3 + 5, mod = 998244353;
int a[N], dp[N], ans = 0, sum = 0;

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int n; cin >> n;
    for(int i = 1; i <= n; ++i) cin >> a[i], sum += a[i];
    sort(a + 1, a + 1 + n);
    dp[0] = 1;
    for(int i = 1; i <= n; ++i){
        for(int j = 0; j <= a[i]; ++j) ans = (ans + a[i] * dp[j]) % mod;
        for(int j = a[i] + 1; j <= sum; ++j) ans = (ans + (dp[j] * ((j + a[i] + 1) / 2)) % mod) % mod;
        for(int j = sum; j >= a[i]; --j) dp[j] = (dp[j] + dp[j - a[i]]) % mod;
    }
    cout << (ans % mod + mod) % mod << endl;
    return 0;
}
```