## 题目描述

房间里放着 $n$ 块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 $(0,0)$ 点处。

## 输入格式

第一行有一个整数，表示奶酪的数量 $n$。

第 $2$ 到第 $(n + 1)$ 行，每行两个实数，第 $(i + 1)$ 行的实数分别表示第 $i$ 块奶酪的横纵坐标 $x_i, y_i$。

## 输出格式

输出一行一个实数，表示要跑的最少距离，保留 $2$ 位小数。

## 输入输出样例 #1

### 输入 #1

```
4
1 1
1 -1
-1 1
-1 -1
```

### 输出 #1

```
7.41
```

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1\leq n\leq 15$，$|x_i|, |y_i| \leq 200$，小数点后最多有 $3$ 位数字。

#### 提示

对于两个点 $(x_1,y_1)$，$(x_2, y_2)$，两点之间的距离公式为 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

---

$2022.7.13$：新增加一组 $\text{Hack}$ 数据。

### Solution
**状态压缩**的思想是用二进制来表示状态。用一个整数的二进制形式的每一个二进制位 0 或 1 表示一个状态。
本题是一道比较基础的状压DP题目。
状压DP的时间复杂度为 $O(n^22^n)$，通常只能通过 N≤21 的数据范围，本题数据范围为 N≤15 因此可以使用状压DP。
#### 思路
坐标可能为实数，因此要用double类型存储。
定义一个数组 Fi,j​，表示老鼠走到第 i 个奶酪，且走过的二进制状态为 j 时，最短的距离。

举例来说，可以使用二进制 10100110 来表示已经走过第 2、3、6、8 个奶酪，此时 j 的值为 166。需要注意的是，第 i 个状态是从低位向高位的第i位。

在更新 F 数组状态时会用到两点间的距离，使用两点间距离公式计算.

首先要将 F 数组进行初始化为极大值，可以使用`memset(F,127,sizeof(F));`来为浮点数赋极大值

因为到达第 i 块奶酪，且只经过过第 i 块奶酪的距离即为第i块奶酪与坐标原点的距离。因此要初始化`dp[i][(1<<(i-1))]=dis[0][i];`。

接下来是三层循环，分别枚举所有可能的二进制状态、当前点所在的位置和能在当前状态下到达当前点的位置。

在第二层循环中要判断一下 i 在当前二进制状态下是否已走过，如果根本没走过则不需要进行接下来的计算，直接continue就可以。
在第三层运算中同样要判断当前点是否已走过，且当前点不与 i 点相同。
接下来就可以转移状态了：
设此时二进制状态为 k，终点为 i，起点为 j，可得状态转移方程：$dp[i][S] = min(dp[i][S], dp[j][S - (1 << (i - 1))] + dis[i][j])$
其中 $dp[j][S - (1 << (i - 1))]$ 表示在j点且没走过i点的最短距离(减掉其二进制表示即可), $dis[i][j]$ 表示i到j的距离
遍历$min(ans, dp[i][1 << (i - 1)])$ 即可

### AC Code
```
#include <bits/stdc++.h>
using namespace std;
const int N = 18;
double x[N], y[N], dist[N][N], dp[18][1 << 18];
double dis(double x1, double y1, double x2, double y2){
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

int main(){
    ios::sync_with_stdio(0), cin.tie(0);
    int n; cin >> n;
    memset(dp, 127, sizeof(dp));
    double ans = dp[0][0];
    for(int i = 1; i <= n; ++i) cin >> x[i] >> y[i];
    x[0] = y[0] = 0;
    for(int i = 0; i <= n; ++i){
        for(int j = 0; j <= n; ++j) dist[i][j] = dis(x[i], y[i], x[j], y[j]);
    }
    dp[0][0] = 0;
    for(int i = 1; i <= n; ++i) dp[i][1 << (i - 1)] = dist[0][i];
    for(int S = 1; S < (1 << n); ++S){
        for(int i = 1; i <= n; ++i){
            if(!(S & (1 << (i - 1)))) continue;
            for(int j = 1; j <= n; ++j){
                if(i == j) continue;
                if(S & (1 << (j - 1))) dp[i][S] = min(dp[i][S], dp[j][S ^ (1 << (i - 1))] + dist[i][j]);
            }
        }
    }
    for(int i = 1; i <= n; ++i) ans = min(ans, dp[i][(1 << n) - 1]);
    cout << fixed << setprecision(2) << ans << '\n';
    return 0;
}
```