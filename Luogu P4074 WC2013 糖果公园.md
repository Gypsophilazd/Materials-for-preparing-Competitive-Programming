![[Pasted image 20250819165000.png]]
## 题目描述

Candyland 有一座糖果公园，公园里不仅有美丽的风景、好玩的游乐项目，还有许多免费糖果的发放点，这引来了许多贪吃的小朋友来糖果公园游玩。

糖果公园的结构十分奇特，它由 $n$ 个游览点构成，每个游览点都有一个糖果发放处，我们可以依次将游览点编号为 $1$ 至 $n$。有 $n - 1$ 条双向道路连接着这些游览点，并且整个糖果公园都是连通的，即从任何一个游览点出发都可以通过这些道路到达公园里的所有其它游览点。

糖果公园所发放的糖果种类非常丰富，总共有 $m$ 种，它们的编号依次为 $1$ 至 $m$。每一个糖果发放处都只发放某种特定的糖果，我们用 $C_i$ 来表示 $i$ 号游览点的糖果。

来到公园里游玩的游客都不喜欢走回头路，他们总是从某个特定的游览点出发前往另一个特定的游览点，并游览途中的景点，这条路线一定是唯一的。他们经过每个游览点，都可以品尝到一颗对应种类的糖果。

大家对不同类型糖果的喜爱程度都不尽相同。 根据游客们的反馈打分，我们得到了糖果的美味指数， 第 $i$ 种糖果的美味指数为 $V_i$。另外，如果一位游客反复地品尝同一种类的糖果，他肯定会觉得有一些腻。根据量化统计，我们得到了游客第 $i$ 次品尝某类糖果的新奇指数 $W_i$。如果一位游客第 $i$ 次品尝第 $j$ 种糖果，那么他的愉悦指数 $H$ 将会增加对应的美味指数与新奇指数的乘积，即 $V_j \times W_i$。这位游客游览公园的愉悦指数最终将是这些乘积的和。

当然，公园中每个糖果发放点所发放的糖果种类不一定是一成不变的。有时，一些糖果点所发放的糖果种类可能会更改（也只会是 $m$ 种中的一种），这样的目的是能够让游客们总是感受到惊喜。

糖果公园的工作人员小 A 接到了一个任务，那就是根据公园最近的数据统计出每位游客游玩公园的愉悦指数。但数学不好的小 A 一看到密密麻麻的数字就觉得头晕，作为小 A 最好的朋友，你决定帮他一把。

## 输入格式

第一行包含三个正整数 $n, m, q$， 分别表示游览点个数、 糖果种类数和操作次数。

第二行包含 $m$ 个正整数 $V_1, V_2, \ldots, V_m$。

第三行包含 $n$ 个正整数 $W_1, W_2, \ldots, W_n$。

第四行到第 $n + 2$ 行，每行包含两个正整数 $A_i, B_i$，表示这两个游览点之间有路径可以直接到达。

第 $n + 3$ 行包含 $n$ 个正整数 $C_1, C_2, \ldots, C_n$。

接下来 $q$ 行， 每行包含三个整数 $Type, x, y$，表示一次操作：

- 若 $Type$ 为 $0$，则 $1 \leq x \leq n$， $1 \leq y \leq m$，表示将编号为 $x$ 的游览点发放的糖果类型改为 $y$；
- 若 $Type$ 为 $1$，则 $1 \leq x, y \leq n$，表示对出发点为 $x$，终止点为 $y$ 的路线询问愉悦指数。

## 输出格式

按照输入的先后顺序，对于每个 $Type$ 为 $1$ 的操作输出一行，用一个正整数表示答案。

## 输入输出样例 #1

### 输入 #1

```
4 3 5
1 9 2
7 6 5 1
2 3
3 1
3 4
1 2 3 2
1 1 2
1 4 2
0 2 1
1 1 2
1 4 2
```

### 输出 #1

```
84
131
27
84
```

## 说明/提示

【样例解释】

我们分别用

![](https://cdn.luogu.com.cn/upload/image_hosting/isw3ib3u.png)

代表 $C_i$ 为 $1$、 $2$、 $3$ 的节点，在修改之前：

![](https://cdn.luogu.com.cn/upload/image_hosting/ttkzii1u.png)

在将 $C_2$ 修改为 $1$ 之后：

![](https://cdn.luogu.com.cn/upload/image_hosting/izro364w.png)

【数据规模与约定】

对于所有的数据： $1 \leq V_i, W_i \leq 10^6$，$1 \leq A_i, B_i \leq n$， $1 \leq C_i \leq m$， $W_1, W_2, \ldots, W_n$ 是非递增序列，即对任意 $1 < i \leq n$， 满足 $W_i \le W_{i-1}$。

其它的限制条件如下表所示：

![QQ20180113072014.png](https://cdn.luogu.com.cn/upload/image_hosting/g6884nx1.png)


## 题意简述

游客沿着树上一条 **简单路径** 走，每到一个节点吃该节点颜色的糖。

同一颜色第 $i$ 次吃的“新奇度”为 $W_i$，颜色 $c$ 的“美味度”为 $V_c$。

路径的总愉悦值：$\sum_{c=1}^{m} \left( V_c \cdot \sum_{i=1}^{\mathrm{cnt}_c} W_i \right)$

其中 $\mathrm{cnt}_c$ 是**路径上颜色 $c$ 出现次数**。


如果我们能在查询路径上快速维护 **每种颜色的出现次数**，就能在 $O(1)$ 代价下更新答案（见第 3 节“增删一个节点”的增量公式）。


## 思路

### 1. 利用欧拉序将树上路径变成数组区间

对树做一次 DFS，**每个节点进栈和出栈各记录一次**：

- $\text{tin}[u]$：第一次到达 $u$ 的时间戳； 

- $\text{tout}[u]$：从 $u$ 返回（离开）时的时间戳；

- $\text{seq}[1..2n]$：长度为 $2n$ 的欧拉序列，$\text{seq}[t]$ 表示时刻 $t$ 扫到的节点。


**关键性质**：在欧拉序中的任意区间 $[L,R]$，统计每个节点在该区间内出现的次数，**出现奇数次的那些节点，恰好对应某条树上路径上的节点集合**。

> 直观理解：一个节点在欧拉序中出现两次（进、出）。当区间刚好覆盖到它的一半时，它出现 1 次（奇数），代表它还没出去；当完全覆盖它的进与出，出现 2 次（偶数），被抵消。

---

令 $w=\mathrm{LCA}(u,v)$，并保证 $\text{tin}[u] \le \text{tin}[v]$（必要时交换）。

- **情况 1：** 如果 $w = u$，那么路径 $(u \to v)$ 就对应 **欧拉序区间** $[\text{tin}[u],\, \text{tin}[v]]$。即直链。

- **情况 2：** 如果 $w \ne u$，那么路径对应 **欧拉序区间** $[\text{tout}[u],\, \text{tin}[v]]$，但此时 LCA $w$ 在区间中被抵消了（出现偶数次），**需要把 $w$ 这个点再加一次**。即折链

很简单的道理，画个图就可以明白。这样即可将树上一条路径映射到数组上。

### 3. O(1) 维护答案
设：

- $\text{C}[u]$：节点 $u$ 的当前颜色（会随修改变化）；

- $\text{cnt}[c]$：当前集合中颜色 $c$ 出现次数；

- $\text{vis}[u]$：在当前区间中，节点 $u$ 是否“被选中”（出现奇数次）。

当我们把节点 $u$ **加入集合**（从 $\text{vis}[u]=0$ 变为 $1$）：

- $\text{cnt}[\text{C}[u]] +1$；

- 答案增量：$+\, V_{\text{C}[u]} \cdot W_{\text{cnt}[\text{C}[u]]}$。

当我们把节点 $u$ **移出集合**（从 $\text{vis}[u]=1$ 变为 $0$）：

- 答案增量：$-\, V_{\text{C}[u]} \cdot W_{\text{cnt}[\text{C}[u]]}$；

- $\text{cnt}[\text{C}[u]] - 1$。

> 实现上可设 $W[0] = 0$，这样第一次加入时自然取 $W_1$。
  
---  
### 4. 树上带修莫队

把操作全部离线。排序时用三关键字：

$(\lfloor L/B \rfloor, \lfloor R/B \rfloor, t)$，其中 $B \approx (2n)^{2/3}$。

把修改操作看做时间戳，把每个询问加上一个时间戳 $[l, r, tim, lca]$

对于每个询问，先按普通莫队做区间拓展，再考虑修改。设从$[l_i, r_i, i]$ 拓展到 $[l_j, r_j, j]$，根据时间戳考虑修改的贡献。

1. 若 $j > i$ 需要把第 $i + 1$ 个到第 $j$ 个修改的贡献加上。

2. 若 $j < i$ 需要把第 $i$ 个到第 $j +1$ 个修改的贡献还原。

### 5. 时间复杂度

- 修改操作均为都是 $O(1)$；  

- 总复杂度 $\tilde O((n+q)\cdot (2n)^{2/3})$，可过 $10^5$ 量级。  


## Code
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
int n, m, k;
int V[N], W[N], C[N], fa[N][20];
int dep[N], tin[N], tout[N], seq[N << 1], tim = 0;
int pos[N], newC[N], cnt[N], ans[N], sum, tot;
bool vis[N];
vector<int> g[N];
int B;


void dfs1(int x, int p){ //倍增法求lca
    dep[x] = dep[p] + 1; fa[x][0] = p;
    for(int i = 1; i <= 19; ++i) fa[x][i] = fa[fa[x][i - 1]][i - 1];
    for(const auto &y : g[x]){
        if(y == p) continue;
        dfs1(y, x);
    }
}


int lca(int x, int y){
    if(dep[x] < dep[y]) swap(x, y);
    for(int i = 19; i >= 0; --i) if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
    if(x == y) return x;
    for(int i = 19; i >= 0; --i) if(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
    return fa[x][0];
}

void dfs2(int u, int p){ // 求欧拉序
    tin[u] = ++tim; seq[tim] = u; // 进 u 时刻
    for(const auto &v : g[u]){
        if(v == p) continue;
        dfs2(v, u);
    }
    tout[u] = ++tim; seq[tim] = u; // 出 u 时刻
}


struct Q{ // 询问
    int l, r, t, id, lca;
    // 按 l/B, r/B 和 tim 排序
    bool operator<(Q &b){
        if(l / B != b.l / B) return l < b.l;
        if(r / B != b.r / B) return r < b.r;
        return t < b.t;
    }
}q[N];


void add(int x){
    vis[x] ^= 1; // 访问 x 点的次数 奇数加，偶数减
    if(vis[x]) sum += W[++cnt[C[x]]] * V[C[x]];
    else sum -= W[cnt[C[x]]--] * V[C[x]];
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m >> k; // 点，糖果种类，操作
    for(int i = 1; i <= m; ++i) cin >> V[i]; //美味
    W[0] = 0;
    for(int i = 1; i <= n; ++i) cin >> W[i]; //新奇
    for(int i = 1; i <= n - 1; ++i){
        int x, y; cin >> x >> y;
        g[x].push_back(y), g[y].push_back(x);
    }
    dfs1(1, 0); dfs2(1, 0);
    for(int i = 1; i <= n; ++i) cin >> C[i]; //糖果类型
    for(int i = 1, t = 0; i <= k; ++i){
    // 预处理
        int op, x, y; cin >> op >> x >> y;
        if(op == 1){
        // 区间查询
            int LCA = lca(x, y);
            q[++tot].t = t; q[tot].id = tot;
            if(tin[x] > tin[y]) swap(x, y);
            if(LCA == x) q[tot].l = tin[x], q[tot].r = tin[y]; // 直链
            else q[tot].l = tout[x], q[tot].r = tin[y], q[tot].lca = LCA; // 长链
        }
        else pos[++t] = x, newC[t] = y;
        // 点修，位置和修改值
    }

    //树上带修莫队
    B = pow(2 * n, 0.66);
    sort(q + 1, q + 1 + tot);
    for(int i = 1, l = 1, r = 0, t = 0; i <= tot; ++i){
        while(l > q[i].l) add(seq[--l]);
        while(r < q[i].r) add(seq[++r]);
        while(l < q[i].l) add(seq[l++]);
        while(r > q[i].r) add(seq[r--]);
        while(t < q[i].t){ //时间戳变大则替换
            ++t;
            if(vis[pos[t]]){
                add(pos[t]);
                swap(C[pos[t]], newC[t]); //换成修改值
                add(pos[t]);
            }
            else swap(C[pos[t]], newC[t]);
        }
        while(t > q[i].t){ //时间戳变小则还原
            if(vis[pos[t]]){
                add(pos[t]);
                swap(C[pos[t]], newC[t]); //还原
                add(pos[t]);
            }
            else swap(C[pos[t]], newC[t]);
            t--;
        }
        ans[q[i].id] = sum;
        if(q[i].lca) ans[q[i].id] += W[cnt[C[q[i].lca]] + 1] * V[C[q[i].lca]]; //加上lca贡献
    }
    for(int i = 1; i <= tot; ++i) cout << ans[i] << '\n';
    return 0;
}
```