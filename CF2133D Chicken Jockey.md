## 题意简述

有一座由 $n$ 个怪物垒成的“鸡骑士”（从下到上编号 $1..n$），第 $i$ 个怪物初始生命为 $h_i$。

每次攻击可对任意一个怪物造成 $1$ 点伤害；当某个怪物生命值 $≤ 0$ 时死亡，它**上方**的所有怪物会整体掉落，形成一个新栈；新栈的底部怪物会受到坠落伤害，数值等于它**在掉落前**下方有多少个怪物。若因此它也死了，上方怪物继续掉落并重复上述过程。目标是用**最少**的攻击次数杀死所有怪物。

贯穿本题的坑点：某个怪物受到的**坠落伤害只取决于它在掉落前下面有多少个怪物**，也就是它的**坠落高度**；与其他过程无关。

## Solution

把初始单栈从下到上编号 $1..n$，血量 $h[1..n]$。

如果我们始终攻击当前栈的最底部怪直到它死：

第一个怪 $1$ 要打满 $h[1]$ 次；对于 $i \ge 2$，当 $i - 1$ 死时，$i$ 会作为掉落后新栈的底部，受到 $1$ 点坠落伤，即少一次攻击。因此对 $i$ 的攻击次数是 $\max(0, h[i] - 1)$。

于是最朴素的代价为：

$$res = h[1] + \sum_{i = 2}^{n} \max(0, h[i] - 1)$$
考虑优化。我们可以不总是打底部，而是提前把某个非底部怪 $j\space(2 ≤ j ≤ n-1)$ 打死。

朴素计算中，$j + 1$ 只有 $1$ 点坠落伤，所以，对 $j+1$ 的攻击次数是：$\max(0, h[j+1] - 1)$。

而提前攻击 $j$，即在它还没轮到自己变成底部前就打死。此时，$j+1$ 会直接从高度 $j$ 掉下去，得到 $j$ 点坠落伤害。

> 坑点：$j+1$ 的坠落伤害只看它掉落前的高度 $j$，与其它步骤无关。

所以对 $j+1$ 的攻击次数是：$\max(0,\, h[j+1] - j)$，分类讨论后得到差值为 $\min(j-1, \max(0, h[j+1]-1))$ 次攻击。

因此提前击杀 $j$ 的贡献是：

$$f_j = \max(0,\min(j-1, \max(0, h[j+1]-1)) - 1)$$

如果选择了提前击杀 $j$，其收益是作用在目标 $j + 1$ 上。而选择提前击杀 $j+1$ ，则会与前者相互干扰，不能同时独立计算贡献。

考虑正难则反，设答案为朴素计算的结果减去从 $f_j$ 中不相邻的最大和。

实现时，二维滚动以节省空间。

`det`：即当前位置 $j$ 的可获得贡献 。

`a`：处理到 $j-1$ 时，且 选了 $j-1$ 的最大收益。

`b`：处理到 $j-1$ 时，且 没选 $j-1$ 的最大收益。

时间复杂度 $O(n)$。

## Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int t; cin >> t;
    while(t--){
        int n; cin >> n;
        vector<int> h(n + 1);
        for(int i = 1; i <= n; ++i) cin >> h[i];
        int res = h[1];
        for(int i = 2; i <= n; ++i) res += max(0ll, h[i] - 1);
        int a = 0, b = 0; //a b含义如上
        for(int i = 2; i <= n - 1; ++i){
            int det = min(i - 2, max(0ll, h[i + 1] - 2));
            if(det < 0) det = 0;
            // 到当前位置 i
            // a1 = b + det  选 i 的话，i-1 不能选，所以只能从 b 来。
            // b1 = max(a, b) 不选 i 的话，对 j-1 没限制。
            int a1 = b + det, b1 = max(a, b);
            a = a1, b = b1;
        }
        int ans = max(a, b);
        cout << (res - ans) << "\n";
    }
    return 0;
}
```

![[chicken jockey 1.png]]