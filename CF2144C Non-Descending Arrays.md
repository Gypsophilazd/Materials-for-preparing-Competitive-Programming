## 题目描述

给定两个长度为 $n$ 的整数数组 $a$ 和 $b$。

你可以选择任意一组下标的子集，并将这些位置上的元素进行交换（即对于每个下标 $i$，执行 swap($a_i$, $b_i$)）。如果在交换之后，两个数组都按非递减顺序排列，则该下标子集被认为是“好的子集”。

你的任务是计算“好子集”的数量。由于答案可能很大，请输出对 $998244353$ 取模后的结果。

## 输入格式

第一行包含一个整数 $t$（$1 \leq t \leq 500$）——表示测试用例的数量。

每个测试用例的第一行包含一个整数 $n$（$1 \leq n \leq 100$）。

第二行包含 $n$ 个整数 $a_1, a_2, \dots, a_n$（$1 \leq a_i \leq 1000$）。

第三行包含 $n$ 个整数 $b_1, b_2, \dots, b_n$（$1 \leq b_i \leq 1000$）。

输入保证对于每组测试数据，至少存在一个好子集。

## 输出格式

对于每个测试用例，输出一个整数，表示好子集的数量，对 $998244353$ 取模。

## 输入输出样例 #1

### 输入 #1

```
3
3
2 1 4
1 3 2
1
4
4
5
2 3 3 4 4
1 1 3 5 6
```

### 输出 #1

```
2
2
8
```

## 说明/提示

在第一个样例中，有 $2$ 个好子集：$\{1, 3\}$ 和 $\{2\}$。

在第二个样例中，有 $2$ 个好子集：$\{1\}$ 和 $\{\}$。

在第三个样例中，有 $8$ 个好子集：$\{1, 2, 3, 4, 5\}$，$\{1, 2, 3\}$，$\{1, 2, 4, 5\}$，$\{1, 2\}$，$\{3, 4, 5\}$，$\{3\}$，$\{4, 5\}$ 和 $\{\}$。

## Solution

题目要求最终为非递减数列，且允许无限次交换，故考虑 `dp` 解决。
考虑状态设计，设 `dp[i][0/1]` 表示下标为 $i$ 的位置不交换($0$)或交换($1$)之后非递减子集的数量。
接下来考虑状态转移，无非就是针对 $a_i,b_i$ 的大小关系进行分类讨论。
$$\begin{equation}
\begin{cases}
dp[i][0] = dp[i - 1][0] + dp[i][0]& \text{ $ (a[i-1]  \le a[i]且 b[i-1] \le b[i]) $ } \\
dp[i][0] = dp[i - 1][1] + dp[i][0]& \text{ $ (a[i-1]  \le b[i]且 a[i-1] \le b[i]) $ } \\
dp[i][1] = dp[i - 1][0] + dp[i][1]& \text{ $ (a[i-1]  \le b[i]且 a[i-1] \le b[i]) $ } \\
dp[i][1] = dp[i - 1][1] + dp[i][1]& \text{ $ (a[i-1]  \le a[i]且 b[i-1] \le b[i]) $ }
\end{cases}
\end{equation}$$
其实画图可以很方便得出状态转移方程。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int N = 1e3 + 5;
int dp[N][N];
int main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int t; cin >> t;
    while(t--){
        int n; cin >> n;
        vector<int> a(n + 1), b(n + 1);
        for(int i = 1; i <= n; i++) cin >> a[i];
        for(int i = 1; i <= n; i++) cin >> b[i];
        memset(dp, 0, sizeof(dp));
        dp[1][0] = 1, dp[1][1] = 1;
        for(int i = 2; i <= n; i++){
            if(a[i - 1] <= a[i] && b[i - 1] <= b[i]) dp[i][0] = (dp[i][0] + dp[i - 1][0]) % mod;
            if(b[i - 1] <= a[i] && a[i - 1] <= b[i]) dp[i][0] = (dp[i][0] + dp[i - 1][1]) % mod;
            if(a[i - 1] <= b[i] && b[i - 1] <= a[i]) dp[i][1] = (dp[i][1] + dp[i - 1][0]) % mod;
            if(b[i - 1] <= b[i] && a[i - 1] <= a[i]) dp[i][1] = (dp[i][1] + dp[i - 1][1]) % mod;
        }
        cout << (dp[n][0] + dp[n][1]) % mod << "\n";
    }
    return 0;
}

```