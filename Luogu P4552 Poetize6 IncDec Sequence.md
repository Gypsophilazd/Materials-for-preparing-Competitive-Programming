## 题目描述

给定一个长度为 $n$ 的数列 ${a_1,a_2,\cdots,a_n}$，每次可以选择一个区间$[l,r]$，使这个区间内的数都加 $1$ 或者都减 $1$。 
  
请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。

## 输入格式

第一行一个正整数 $n$   
接下来 $n$ 行,每行一个整数,第 $i+1 $行的整数表示 $a_i$。

## 输出格式

第一行输出最少操作次数   
第二行输出最终能得到多少种结果

## 输入输出样例 #1

### 输入 #1

```
4
1
1
2
2
```

### 输出 #1

```
1
2
```

## 说明/提示

对于 $100\%$ 的数据，$n\le 100000, 0 \le a_i \le 2^{31}$。



### Solution
非常非常好的思维题，仅用到了差分的思维。
注意到我们每次可以选择一个区间 $[l,r]$ 使得区间内每个数 +1 或者 -1，我们理所应当的想到了差分数组,将区间操作改成两点操作。
也就是说,我们可以选出 b 数组中任意两个数，一个数+1， 另一个-1，把 $b_2,b_3...b_n$ 全变为 0，这样进行前缀和操作后 a 数组便只剩一个数。
我们一共有四种操作：
1. 选 $b_i$ 和 $b_j$($2 \le i, j \le n$),贪心的想，让他们正负配对相消，使其尽可能接近0;
2. 选 $b_1$ 和 $b_j$($2 \le j \le n$)，让 $b_j$ 尽可能接近0；
3. 选 $b_i$ 和 $b_n$($2 \le i \le n$)，让 $b_i$ 尽可能接近0；
4. 选 $b_1$ 和 $b_{n+1}$ 但是这种操作没有意义，无法改变 $b_2...b_n$ 的值
设 $b_2,b_3...b_n$ 中的正数总和 $p$,负数绝对值总和 $q$。
以正负数配对方式执行操作1,需要执行 $min(p, q)$ 次。
剩下 $|p - q|$ 个没有配对,每一个可以选与 $b_1$ 或者 $b_{n+1}$ 配对,执行操作2或者操作3,需要执行 $|p - q|$ 次
那么最少的操作次数就是 $min(p, q) + |p - q| = max(p, q)$ 次
而根据 $|p - q|$ 次操作2, 3 可以得到$b_1, b_1 + 1, ... , b_1 + |p - q|$ 种值.
所以得到的序列数为 $|p - q| + 1$;

### Code
```
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 1e5 + 5;

int a[N], b[N];

  

signed main(){

    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

    int n; cin >> n;

    for(int i = 1; i <= n; ++i) cin >> a[i];

    for(int i = 1; i <= n; ++i) b[i] = a[i] - a[i - 1];

    int p = 0, q = 0;

    for(int i = 2; i <= n; ++i){

        if(b[i] > 0) p += b[i];

        else q += abs(b[i]);

    }

    cout << max(p, q) << '\n' << abs(p - q) + 1 << '\n';

    return 0;

}
```