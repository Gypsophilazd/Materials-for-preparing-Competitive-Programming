![[Pasted image 20250822170306.png]]
## 题目描述

几乎整个 Byteland 王国都被森林和河流所覆盖。小点的河汇聚到一起，形成了稍大点的河。就这样，所有的河水都汇聚并流进了一条大河，最后这条大河流进了大海。这条大河的入海口处有一个村庄——名叫 Bytetown。

在 Byteland 国，有 $n$ 个伐木的村庄，这些村庄都座落在河边。目前在 Bytetown，有一个巨大的伐木场，它处理着全国砍下的所有木料。木料被砍下后，顺着河流而被运到 Bytetown 的伐木场。Byteland 的国王决定，为了减少运输木料的费用，再额外地建造 $k$ 个伐木场。这 $k$ 个伐木场将被建在其他村庄里。这些伐木场建造后，木料就不用都被送到 Bytetown 了，它们可以在运输过程中第一个碰到的新伐木场被处理。显然，如果伐木场座落的那个村子就不用再付运送木料的费用了。它们可以直接被本村的伐木场处理。

注：所有的河流都不会分叉，形成一棵树，根结点是 Bytetown。

国王的大臣计算出了每个村子每年要产多少木料，你的任务是决定在哪些村子建设伐木场能获得最小的运费。其中运费的计算方法为：每一吨木料每千米 $1$ 分钱。

## 输入格式

第一行包括两个整数 $n,k$。$n$ 为村庄数，$k$ 为要建的伐木场的数目。除了 Bytetown 外，每个村子依次被命名为 $1,2,3\ldots n$，Bytetown 被命名为 $0$。

第 $2$ 到第 $(n + 1)$ 行，每行 $3$ 个整数，第 $(i + 1)$ 行的整数分别代表，分别表示每年 $i$ 村子产的木料的块数 $w_i$，离 $i$ 村子下游最近的村子 $v_i$（即 $i$ 村子的父结点），$v_i$ 到 $i$ 的距离 $d_i$（千米）。

## 输出格式

输出最小花费，单位为分。

## 输入输出样例 #1

### 输入 #1

```
4 2
1 0 1
1 1 10
10 2 5
1 2 3
```

### 输出 #1

```
4
```

## 说明/提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n\le 20$。
- 对于 $100\%$ 的数据，保证 $2\le n\le 100$，$1\le k\le \min(n,50)$，$0\le v_i\le n$，$0\le w_i\le 10^4$，$1\le d_i\le 10^4$。
- 保证每年所有的木料流到 bytetown 的运费不超过 $2\times 10^9$ 分。

## Solution
![[Pasted image 20250406113453.png]]
### 题意简析

给定一棵以0号点为根的树，给定点权，边权，以限定特定点的数量为背包体积，求代价最小值。
按照一般的树上背包做法,设 $dp[u][j]$ 表示当前在 $u$ 点， $u$ 及 $u$ 的子树建了 $j$ 个伐木场的运费最小值，但是如果这样设，$u$ 子树中没有处理的木料怎么办?
所以 我们需要考虑 $u$ 子树中没处理的木料运到何处,即需要引入已建设伐木场点的最近祖先
$i$

**设 $dp[u][i][j]$ 表示当前在 $u$ 点,建了伐木场的最近祖先$i$ ，$u$ 与 $u$ 的子树建了 $j$ 个伐木场的运费最小值($u$ 可能没建伐木场)**

**设$g[u][i][j]$表示当前在 $u$ 点，建了伐木场的最近祖先 $u$ ， *$u$ 建了伐木场*，$u$ 的子树建了 $j$ 个伐木场的运费最小值。**

**用d\[u]记录根到u的距离**

**用stk栈记录包括u本身,从根走到u的所有祖先**，把伐木场总数 $k$ 视作0-1背包的容量,进行决策转移。

![[Pasted image 20250406114422.png]]
### 状态转移方程
1. 遍历u的每个子树时，只处理子树中的木料,不处理u中的木料，避免重复处理

 $$dp[u][i][j] = min(dp[u][i][j], dp[u][i][j - t] + dp[v][i][t])$$
$$g[u][i][j] = min(g[u][i][j] + g[u][i][j - t] + dp[v][u][t]) i∈stk, j∈[k,0], t∈[0,j]$$
 $g$ 转移 + $dp[v][u][t]$  $v$ 及 $v$ 的子树建了 $k$ 个伐木场，$u$ 是建伐木场的最近祖先。

2. 遍历完 $u$ 的所有子树后，再处理 $u$ 点的木料

$$dp[u][i][j] = min(dp[u][i][j] + w[u]·(d[u] - d[i]), g[u][i][j - 1])$$
若 $u$ 点没建伐木场，就运到祖先i上处理,即已有运费+按公式计算运费
若 $u$ 点建了伐木场，那么 $u$ 的子树只能建 $j-1$ 个,取$g[u][i][j - 1]$

 3. 初始化dp,  $g$ 维护最小值，初始化为当前 $v$ 子树的最大值，$v$ 子树若没有伐木场肯定最大。
```
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
int dp[N][N][N]; //dp[u][i][j] 表示在u点, 建了伐木场的最近祖先i,u及u的子树建了j个伐木场的最小花费(u可能没建)
int g[N][N][N]; //g[u][i][j]表示在u点一定建了伐木场, 建了伐木场的最近祖先i,u的子树建了j个伐木场的最小花费
int d[N], w[N], s[N], n, k;
vector<int> e[N], stk;

void dfs(int u){
    stk.push_back(u);
    for(int v : e[u]){
        d[v] = d[u] + s[v];
        dfs(v);
        
        for(auto i : stk){
            for(int j = k; j >= 0; --j){
                dp[u][i][j] += dp[v][i][0];
                g[u][i][j] += dp[v][u][0];
                for(int t = 0; t <= j; ++t){
                    dp[u][i][j] = min(dp[u][i][j], dp[u][i][j - t] + dp[v][i][t]);
                    g[u][i][j] = min(g[u][i][j], g[u][i][j - t] + dp[v][u][t]);
                }
            }
        }
    }
    for(auto i : stk){
        for(int j = k; j >= 1; --j) dp[u][i][j] = min(dp[u][i][j] + w[u] * (d[u] - d[i]), g[u][i][j - 1]);
        dp[u][i][0] += w[u] * (d[u] - d[i]);
    }
    stk.pop_back();
}

int main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> k;
    for(int i = 1; i <= n; ++i){
        int v; cin >> w[i] >> v >> s[i];
        e[v].push_back(i);
    }
    dfs(0);
    cout << dp[0][0][k] << endl;
    return 0;
}
```