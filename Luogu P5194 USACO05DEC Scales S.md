## 题目描述

约翰有一架用来称牛的体重的天平。与之配套的是 $N \ ( 1 \leq N \leq 1000 )$ 个已知质量的砝码（所有砝码质量的数值都在 $32$ 位带符号整数范围内）。

每次称牛时，他都把某头奶牛安置在天平的某一边，然后往天平另一边加砝码，直到天平平衡，于是此时砝码的总质量就是牛的质量（约翰不能把砝码放到奶牛的那边，因为奶牛不喜欢称体重，每当约翰把砝码放到她的蹄子底下，她就会尝试把砝码踢到约翰脸上）。

天平能承受的物体的质量不是无限的，当天平某一边物体的质量大于 $C \ ( 1 \leq C \leq 2^{30} )$ 时，天平就会被损坏。砝码按照它们质量的大小被排成一行。并且，这一行中从第 $3$ 个砝码开始，每个砝码的质量至少等于前面两个砝码（也就是质量比它小的砝码中质量最大的两个）的质量的和。

约翰想知道，用他所拥有的这些砝码以及这架天平，能称出的质量最大是多少。由于天平的最大承重能力为 $C$，他不能把所有砝码都放到天平上。

现在约翰告诉你每个砝码的质量，以及天平能承受的最大质量，你的任务是选出一些砝码，使它们的质量和在不压坏天平的前提下是所有组合中最大的。

## 输入格式

第 $1$ 行输入两个用空格隔开的正整数 $N$ 和 $C$。

第 $2$ 到 $N+1$ 行：每一行仅包含一个正整数，即某个砝码的质量。保证这些砝码的质量是一个不下降序列。

## 输出格式

输出一个正整数，表示用所给的砝码能称出的不压坏天平的最大质量。

## 输入输出样例 #1

### 输入 #1

```
3 15
1
10
20
```

### 输出 #1

```
11
```



### Solution
很好的暴力搜索+剪枝,使我大脑旋转
注意到题目描述,感觉是一种指数型搜索,但其范围达到了n >= 1000过于恐怖, 即类似斐波那契的增长规模,所以我们需要大量的剪枝
注意到, **每个砝码至少等于其前面两个砝码的和**,故我们进行剪枝,从后往前搜索,能够避免很多不必要的递归,做一个前缀和数组,当cur + w\[idx] 即加上当前位置i的前缀和小于max,即满足要求,因为即便任选前面全部的w\[i]也不可能比max大.

### AC Code
```
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1005;
int w[N], prefix[N], n, c, res = 0, ans = 0;

void dfs(int cur, int idx){
    if(cur + prefix[idx] <= ans) return ;
    ans = max(ans, cur);
    if(idx == 0) return ;
    if(cur + w[idx] <= c) dfs(cur + w[idx], idx - 1);
    dfs(cur, idx - 1);
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> c;
    for(int i = 1; i <= n; ++i){
        cin >> w[i];
        prefix[i] = prefix[i - 1] + w[i];
    }
    for(int i = n; i >= 1; --i) dfs(0, i - 1);
    cout << ans << endl;
    return 0;
}
```