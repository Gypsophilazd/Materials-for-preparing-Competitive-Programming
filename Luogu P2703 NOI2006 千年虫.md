## 题目描述

千年虫是远古时代的生物，时隔几千万年，千年虫早已从地球上销声匿迹，人们对其知之甚少。考古生物学家最近开始对其有了兴趣，因为一批珍贵的千年虫化石被发现，这些化石保留了千年虫近乎完整的形态。

理论科学家们根据这些化石归纳出了千年虫的一般形态特征模型，并且据此判定出千年虫就是蜈蚣的祖先！但科学家 J 发现了实际与理论的一些出入，他仔细的研究了上百个千年虫化石，发现其中大部分千年虫的形态都不完全符合理论模型，这到底是什么因素造成的呢？理论科学家 K 敏锐的指出，千年虫的形态保存在化石中很有可能发生各种变化，即便最细微的变化也能导致它不符合模型。

于是，摆在科学家面前的新问题诞生了：判断一个化石中的千年虫与理论模型的差距有多大？具体来说，就是根据一个千年虫化石的形态 $A$，找到 一个符合理论模型的形态 $B$，使得 $B$ 是最有可能在形成化石时变成形态 $A$。理论学家提出的“千年虫形态特征模型”如下（如左图所示）：躯体由头、尾、躯干、足四大部分构成。

![](https://cdn.luogu.com.cn/upload/pic/1876.png)

- 头，尾用一对平行线段表示。称平行于头、尾的方向为 $x$ 方向；垂直于 $x$ 的方向为 $y$ 方向；

- 在头尾之间有两条互不相交的折线段相连，他们与头、尾两条线段一起围成的区域称为躯干，两条折线段都满足以下条件：拐角均为钝角或者平角，且包含奇数条线段，从上往下数的奇数条垂直于 $x$ 方向。

- 每条折线段从上往下数的第偶数条线段的躯干的另一侧长出一条足，即一个上、下底平行于 $x$ 方向的梯形或矩形，且其中远离躯干一侧的边垂直于 $x$ 方向。

注意：足不能退化成三角形（即底边的长度均大于零），躯干两侧足的数目可以不一样。（如上图，左边有 $4$ 条足，右边有 $5$ 条足）

可见，$x$-$y$ 直角坐标系内，躯干和所有足组成的实心区域的边界均平行或垂直于坐标轴。为了方便，我们假设所有这些边界的长度均为正整数。因此可以认为每个千年虫的躯体 都由一些单位方格拼成。每个单位方格都由坐标 $(x,y)$ 唯一确定。设头尾之间的距离为 $n$，则我们可以用 $2\times n$ 个整数来描述一条千年虫 $B$（如右图）：将 $B$ 沿平行 $x$ 轴方向剖分成 $n$ 条宽度为 $1$ 的横条，每个横条最左边一格的 $x$ 坐标设为 $L_i$，最右一格的的 $x$ 坐标设为 $R_i$。则  $(n,L_1,L_2,\dots,L_n,R_1,R_2,\dots,R_n)$ 就确定了一条千年虫。

由于岁月的侵蚀，在实际发现的化石中，千年虫的形状并不满足上面理论模型的规则，一些格子中的躯体已经被某些矿物质溶解腐蚀了。地质、物理、生物学家共同研究得出：

- 腐蚀是以格子为单位的，只能一整格被腐蚀；

- 腐蚀是分步进行的，每一步只有一格被腐蚀；

- 如果去掉一个格子后躯体不连通了，那么这个格子当前不会被腐蚀；

- 如果一个格子的左边邻格和右边邻格都还没被腐蚀，那么这个格子当前不会被腐蚀；

- 与头相邻的格子不能全部被腐蚀，与尾相邻的格子不能全部被腐蚀。

倘若满足上面五条，我们仍然可以用 $(n,L_1,L_2,\dots,L_n,R_1,R_2,\dots,R_n)$ 来描述一个化石里头的千年虫的形态。其中 $L_i\le R_i$。

![](https://cdn.luogu.com.cn/upload/pic/1879.png)

例如下图：

![](https://cdn.luogu.com.cn/upload/pic/1878.png)

现在你的任务是，输入一个化石里的千年虫的描述 $A$，找一个满足理论模型的千年虫的描述 $B$，使得 $B$ 可以通过腐蚀过程得以变为 $A$，且由 $B$ 转化为 $A$ 的代价（须被腐蚀的格子数）最少。输出此最小代价。

## 输入格式

第一行为一个整数 $n$。

以下 $n$ 行，每行两个整数，其中第 $i$ 行为两个整数 $L'_i$、$R'_i$，用一个空格分开；保证输入数据合法。

## 输出格式

仅一行，为一个整数，表示最少代价。

## 输入输出样例 #1

### 输入 #1

```
7
4 4
3 4
3 5
1 3
2 2
2 4
3 3
```

### 输出 #1

```
3
```

## 说明/提示

【样例说明】

如图：

![](https://cdn.luogu.com.cn/upload/pic/1877.png)

【评分方法】

本题没有部分分，你的程序的输出只有和我们的答案完全一致才能获得满分，否则不得分。

【数据范围】

对于 $30\%$ 的数据，$n\le100$，$R_i\le100$；

对于 $50\%$ 的数据，$n\le1000$，$R_i\le1000$；

对于 $70\%$ 的数据，$n\le10 ^ 5$，$R_i\le 1000$；

对于 $100\%$ 的数据，$1\leq n\le10 ^ 6$，$0\le L_i\le R_i\le10 ^ 6$。

## Solution
#### **问题简化**

给定一个描述化石形态的序列 A，要求构造一个符合理论模型的序列 B，使得 B 通过腐蚀变为 A 的代价最小。腐蚀代价定义为 B 中需要被腐蚀的格子总数。  
**关键条件**：B 的形态必须满足“峰谷交替”的严格波浪形结构（如谷→峰→谷→峰...）。

### **核心思路**

问题可转化为：调整原始序列的每个位置值，使其满足交替的“严格增减”条件，同时最小化总调整幅度。  
1. 每个调整后的值 $bi$只需参考其附近 2-3 个位置的原始值 $aj$，即 $bi∈[aj,aj+1]$。
2. 动态规划（DP）可高效维护状态转移，结合滚动数组优化空间。
1. **`p[2]` 数组**（滚动索引）：
    - 作用：记录当前行和前一行候选值的数量
    - `p[0]` 表示前一行候选值数量
    - `p[1]` 表示当前行候选值数量
    - 初始时 `p[1] = 0` 表示从空候选集开始填充
2. **`m[2][N]` 数组**（候选值容器）：
    - 作用：存储动态规划过程中每一行的候选右边界值
    - 第一维 `[0]` 和 `[1]` 对应滚动数组的交替索引（表示前一行和当前行）
    - 第二维存储具体候选值（例如 `m[1][3]` 表示当前行第3个候选值）
3. **`r[i]` 数组**：
    - 输入数据中的化石右边界描述
    - 表示化石形态第i行的右边界原始值（需通过腐蚀还原为理论模型值）
### **算法设计**

#### **动态规划状态定义**
- **状态表示**：  
    **动态规划（DP）** 用于记录不同状态下的最优解。本题中，$dp[i][j][k]$ 的三维含义如下：

| 维度      | 符号      | 含义                                          |
| ------- | ------- | ------------------------------------------- |
| **位置**  | `i`     | 当前处理到第 `i` 个横条（即序列中的第 `i` 个位置）              |
| **候选值** | `j`     | 第 `i` 个横条的候选值（即调整后的 Li​ 或 Ri​，取值范围为原始值附近的值） |
| **趋势**  | `k=0/1` | 当前趋势：`0` 表示当前值（谷状态），`1` 表示（峰状态）             |
|         |         |                                             |

**候选值生成**：  
    每个位置 i 的候选值仅考虑其前后各两个位置的原始值$aj$，生成 $aj,aj+1,aj+2$，最多 15 个候选值（5 个位置 × 3 个候选）。

#### **状态转移**
**趋势合法性检查**：
    - 若当前候选值 cur > 前一个候选值 prev，则当前趋势必须为上升（k=1）。
    - 若 cur<prev，则趋势必须为下降（k=0）。
    - 若相等，继承前一个趋势。

#### **转移方程**
#### $dp[i][j][k]$ 表示处理到第 `i` 个位置时，第`i`行长为`j`，且当前处于趋势 `k` 的最小总腐蚀代价。
### $dp[i][j][k]=min⁡(dp[i−1][j-1][k], dp[i-1][p][1-k])$
### $(p<j,k==1;p>j,k==0)$ 

#### **滚动数组优化**
- 使用两个数组交替存储当前和前一位置的状态，空间复杂度降至 O(1).
```
int pr = 0, nt = 1; // 滚动数组指针 
for (int i = 2; i <= n; i++) { 
	pr ^= 1, nt ^= 1; // 交替处理 
	// 生成候选值并转移状态 
}
```
#### **双向处理**
- **正向处理**：初始趋势为上升（峰→谷→峰...）。
- **逆向处理**：将序列翻转并转换为 $N−li$，处理初始趋势为下降（谷→峰→谷...），最后取两次结果的最小值。
### **复杂度分析**
- **时间**：$O(n×C)$，其中 C 为候选值数量（约 15），总复杂度接近线性 $O(n)$。
- **空间**：$O(C)$，滚动数组仅维护常数级状态。

### AC Code
```
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 5;
int l[N], r[N], dp[2][N][2];
int m[2][N], p[2];
const int inf = 0x3f3f3f3f;
int n, ans = 0;
  
void solve(){
    memset(dp, 0x3f, sizeof(dp));
    p[1] = 0;// 初始化当前行候选值计数器
    for(int i = 1; i <= 2; ++i){// 遍历前两行
        for(int j = r[i]; j <= r[i] + 2; ++j){// 生成候选值范围
            if(j >= r[1]) m[1][++p[1]] = j;// 筛选有效候选值
        }
    }
    for(int i = 1; i <= p[1]; ++i) dp[1][i][0] = m[1][i] - r[1];
    int a = 0, b = 1; //a为前一行,b为当前行
    for(int i = 2; i <= n; ++i){
        a ^= 1, b ^= 1; p[b] = 0; // 滚动数组优化
        int maxl = max(1ll, i - 2), minr = min(n, i + 2); //生成候选行范围
        for(int j = maxl; j <= minr; ++j){
            for(int k = r[j]; k <= r[j] + 2; ++k){
                if(k >= r[i]) m[b][++p[b]] = k;  //生成候选值
            }
        }
        for(int j = 1; j <= p[b]; ++j){
            dp[b][j][1] = dp[b][j][0] = inf;  //初始化dp数组为inf
            for(int k = 1; k <= p[a]; ++k){
                if(m[a][k] > m[b][j]) dp[b][j][0] = min(dp[b][j][0], dp[a][k][1]); //根据状态转移方程推导
                else if(m[a][k] < m[b][j]) dp[b][j][1] = min(dp[b][j][1], dp[a][k][0]);
                else{
                    dp[b][j][0] = min(dp[b][j][0], dp[a][k][0]);
                    dp[b][j][1] = min(dp[b][j][1], dp[a][k][1]);
                }
            }
            dp[b][j][0] += m[b][j] - r[i]; //将每个候选值塞进dp里面 随后用min取小
            dp[b][j][1] += m[b][j] - r[i];
        }
    }
    int res = inf;
    for(int i = 1; i <= p[b]; ++i) res = min(res, dp[b][i][0]); //最后加上当前行(dp已是累加值)
    ans += res;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n;
    for(int i = 1; i <= n; ++i) cin >> l[i] >> r[i];
    solve();
    for(int i = 1; i <= n; ++i) r[i] = N - l[i];//翻转l[i]再做一遍
    solve();
    cout << ans << endl;
    return 0;
}
```