## 问题描述

有 $n$ 个城市，从起点 $0$ 开始游历每一个城市，只访问每个城市一次，最后回到起点，所需要的最短路径是多少？

尚未发现本题多项式时间复杂度的解法。我们可以穷举全排列，从而获得一个 $Θ((n−1)!)$ 的做法。然而这通常会 $TLE$，所以需要优化。模拟退火是一个很好的思路，但是正确率有时不能得到保证。

那么点集如何表示呢？此类问题由于是$NP−hard$ 问题，$n$ 一般很小，所以可以**状态压缩**，设 $S_i​$ 表示 $S$ 的二进制第 $i$ 位，$S_i​ = 0, 1$表示 $i$ 是否在集合内。

**枚举子集的时间复杂度为$O(2^n)$**

**不妨设点集位于平面直角坐标系内,即二维坐标，则时间复杂度为 $O(n^2)$， 故总时间复杂度为$O(2^nn^2)$。 **
## 解法
### dp含义设计
$dp[i][j]$ 表示走到第 $i$ 个点,且走过的二进制状态为 $j$ 时最短距离。

*举个例子,可以使用二进制10100110表示已经走过的第 $2, 3, 6, 8$ 个点*  第 $i$ 个状态表示**从低位向高位的第 $i$ 位。

### 状态转移方程设计

更新 $dp$ 数组时会使用欧式两点距离公式,将 $dp$ 数组初始化为最大值 `memset(dp, 127, sizeof(dp))`。或者给定整数的 $dis[i][j]$。

 总共 $3$ 层循环:分别枚举所有可能的二进制状态 $s$,当前点所在位置 $i$ 与当前点所在位置可达下一个点 $j$ 的位置。

剪枝:判断一下 $i$ 在当前**二进制状态**是否走过 没走过则不需要计算, 在第三层状态下也需判断 $j$ 在当前二进制状态是否走过,没走过不需要计算且 $j$ 与 $i$ 不相同
### 状态转移方程
#### $$dp[i][S] = min(dp[i][S], dp[j][S - (1 << (i - 1))] + dis[i][j])$$
其中 $dp[j][S - (1 << (i - 1))]$ 表示在j点且没走过i点的最短距离(减掉其二进制表示即可), $dis[i][j]$ 表示 $i$ 到 $j$ 的距离

### $ans = min(ans, dp[i][1 << (i - 1)])$ 即可

[[Luogu P1433 吃奶酪]]
Luogu P1171 售货员的难题（例）

### 题目描述

某乡有 $n\ (2\le n\le 20)$ 个村庄，有一个售货员，他要到各个村庄去售货，各村庄之间的路程 $s\ (0<s<1000)$ 是已知的，且 $A$ 村到 $B$ 村与 $B$ 村到 $A$ 村的路大多不同。为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，假设商店所在的村庄为 $1$，他不知道选择什么样的路线才能使所走的路程最短。请你帮他选择一条最短的路。

### 输入格式

村庄数 $n$ 和各村之间的路程（均是整数）。

第一行，第 $i+1$ 行第 $j$ 个数代表村庄 $i$ 到 $j$ 的单向路径的路程。

### 输出格式

最短的路程。

### 输入输出样例 #1

#### 输入 #1

```
3
0 2 1
1 0 2
2 1 0
```

#### 输出 #1

```
3
```

### Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 21;
const int inf = 2e6;
int dis[N][N], dp[N][1 << N];


signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int n; cin >> n;
    for(int i = 1; i <= n; ++i){
        for(int j = 1; j <= n; ++j) cin >> dis[i][j];
    }
    for(int i = 1; i <= n; ++i){
        for(int j = 0; j < (1 << n); ++j) dp[i][j] = inf;
    }
    dp[1][1 << 0] = 0;
    for(int s = 1; s < (1 << n); ++s){
        for(int j = 1; j <= n; ++j){
            if(!(s & (1 << (j - 1)))) continue;
            for(int i = 1; i <= n; ++i){
                if(i == j) continue;
                if(!(s & (1 << (i - 1)))) continue;
                dp[j][s] = min(dp[j][s], dp[i][s ^ (1 << (j - 1))] + dis[i][j]);
            }
        }
    }
    int ans = inf;
    for(int i = 1; i <= n; ++i) ans = min(ans, dp[i][(1 << n) - 1] + dis[i][1]);
    cout << ans << endl;
    return 0;
}
```