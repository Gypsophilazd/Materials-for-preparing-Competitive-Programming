## 题目描述

假设你是一家商店的老板。为了新一季到来之前清理库存，你决定举行一次全面大促销。

你的店里有 $n$ 种不同的商品，第 $i$ 种商品的售价为 $c_i$ 个金币。每种商品都贴有价格标签，标签上的价格就是 $c_i$。你决定举办一次这样的促销：“我们将所有商品的价格除以 $x$。” 形式上，这意味着你选择一个公约数 $x$，促销期间，第 $i$ 件商品的新价格将变为 $\left\lceil \frac{c_i}{x} \right\rceil$ 个金币（这里 $\left\lceil y \right\rceil$ 表示向上取整）。

为了避免顾客混淆，你需要为所有商品重新贴上印有新价格的标签，但打印新标签是有成本的。具体来说，每打印一个价格标签需要花费 $y$ 个金币。

于是你想到一个妙招——为什么不用现有的标签，在商品之间互换呢？这样只需要为那些没有对应价格标签的商品打印新标签即可。

现在还剩下最后一个问题：你应该将价格缩减多少，也就是应该选择怎样的 $x$ 呢？系数 $x$ 必须是一个**严格大于** $1$ 的整数，并且要使总收入最大化。总收入等于所有商品的新总价值减去打印标签的总成本。

请你计算最大可能的总收入。

## 输入格式

第一行包含一个整数 $t$（$1 \le t \le 10$），表示测试用例的数量。

每个测试用例的第一行包含两个整数 $n$ 和 $y$（$1 \le n \le 2 \cdot 10^5$；$1 \le y \le 10^9$），分别表示商品的数量和每个价格标签的打印成本。

第二行包含 $n$ 个整数 $c_1, c_2, \dots, c_n$（$1 \le c_i \le 2 \cdot 10^5$），表示每件商品的原始价格。

## 输出格式

对于每个测试用例，输出一个整数，表示最大总收入。

## 输入输出样例 #1

### 输入 #1

```
4
5 51
50 150 50 148 150
3 1000000000
42 42 42
10 54321
1 8088 45 1 73 1 9198 4991 1 83
3 100
1 1 1
```

### 输出 #1

```
31
-2999999937
-162755
3
```

## 说明/提示

在第一个测试用例中，最优选择 $x = 3$。此时新价格为 $[17, 50, 17, 50, 50]$。可以利用两个现有的 $50$ 标签，需要为 $17$、$17$ 和 $50$ 共打印三个新标签。所以总收入为 $17 + 50 + 17 + 50 + 50 - 51 \cdot 3 = 31$。

在第二个测试用例中，最优选择 $x = 2$，新价格为 $[21, 21, 21]$，需要为 $3$ 个新标签付费。

在第三个测试用例中，最优选择 $x = 111$。

在第四个测试用例中，最优选择 $x = 2$，新价格与原价完全相同，因此不需要新标签。

## Solution

很好的题，注意到题目给出 $c_i$ 为 $2 \times 10^5$ 的范围，可以猜测应该是根据值域建数组。

重述题意：即给定一个数组 $c_n$ 和 每个标签的代价 $y$，要求我们找到一个最大的大于 $1$ 的正整数 $x$，使得 $\sum_{1}^{n}{⌈\frac{c_i}{x}}​​⌉ - cnt \times y$ 最小。其中 $cnt$ 为总共使用标签的个数，规则认定标签可以重复使用，即已经使用过的标签可以贴到其他商品上。

有一个 naive 的想法是枚举这个正整数 $x$，从 $1$ 枚举到商品的最大值 $mx \ge 2$，在每次枚举中遍历 $n$ 个商品计算代价，这个思路固然正确，但是必然会导致 `TLE`，考虑优化，一个重点方向就是把遍历的 $n$ 个商品进行压缩，考虑迁移数论中的整除分块的思路，有一个重点的观察，即有哪些旧价格 $c_i$ 会变成新价格 $p$？$$⌈\frac{c_i}{x}​​⌉=p⟹p−1<⌈\frac{c_i}{x}​​⌉​​≤p⟹(p−1)x<c_i​≤px$$

这样一来，可以顺理成章的想到使用前缀和优化查找过程。我们枚举每个新价格 $p \le ⌈\frac{mx}{x}​​⌉$，反求出旧价格 $c_i$ 的次数区间（每个旧价格的次数应当被预处理前缀和 `pcnt[N]`），令 $tot = pcnt[r] - pcnt[l-1]$，即当前新价格 $p$ 下的可复用的标签数，先累加当前的收益$sum = tot \times p$，再计算总可以复用的标签数量 $res = \min(cnt[p], tot)$，枚举完当前 $p$ 后，计算 $$ans = \max(ans, sum - (n - res) \times y)$$


## Code
```
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
int c[N], cnt[N], pcnt[N];
signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int t; cin >> t;
    while(t--){
        memset(cnt, 0, sizeof(cnt));
        memset(pcnt, 0, sizeof(pcnt));
        int mx = 0;
        int n, y; cin >> n >> y;
        for(int i = 1; i <= n; ++i){
            cin >> c[i];
            mx = max(mx, c[i]);
            cnt[c[i]]++;
        }
        int ans = LLONG_MIN;
        for(int i = 1; i <= mx; ++i) pcnt[i] = pcnt[i - 1] + cnt[i];
        for(int x = 2; x <= max(2ll, mx); ++x){
            int sum = 0, res = 0;
            int pm = (mx - 1) / x + 1;
            for(int p = 1; p <= pm; ++p){
                int l = (p - 1) * x + 1, r = min(mx, p * x);
                if(l > r) continue;
                int tot = pcnt[r] - pcnt[l - 1];
                if(!tot) continue;
                sum += p * tot;
                if(p <= mx) res += min(cnt[p], tot);
            }
            int c = (n - res) * y;
            ans = max(ans, sum - c);
        }
        cout << ans << '\n';
    }
    return 0;
}

```