![[Pasted image 20250819165000.png]]
# 题目描述

当一束光打到一层玻璃上时，有一定比例的光会穿过这层玻璃，一定比例的光会被反射回去，剩下的光被玻璃吸收。  

设对于任意 $x$，有 $x \times a_i\%$ 单位的光会穿过它，有 $x \times b_i\%$ 的会被反射回去。  
现在 $n$ 层玻璃叠在一起，有 $1$ 单位的光打到第 $1$ 层玻璃上，那么有多少单位的光能穿过**所有** $n$ 层玻璃呢？

## 输入格式

第一行一个正整数 $n$，表示玻璃层数。  
接下来 $n$ 行，每行两个非负整数 $a_i,b_i$，表示第 $i$ 层玻璃的透光率和反射率。

## 输出格式

输出一行一个整数，表示穿透所有玻璃的光对 $10^9 + 7$ 取模的结果。  
可以证明，答案一定为有理数。设答案为 $a/b$ ( $a$ 和 $b$ 是互质的正整数)，你输出的答案为 $x$，你需要保证 $a\equiv bx \space (\text{mod }10^9 + 7)$。

## 输入输出样例 #1

### 输入 #1

```
2
50 20
80 5
```

### 输出 #1

```
858585865
```

## 输入输出样例 #2

### 输入 #2

```
3
1 2
3 4
5 6
```

### 输出 #2

```
843334849
```

## 说明/提示

**样例1解释：**  
![](https://cdn.luogu.com.cn/upload/pic/57125.png)   
如图，光线从左上角打进来，有 $0.5$ 单位的光穿过第 $1$ 层玻璃，有 $0.2$ 单位的光被反射回去。这 $0.5$ 单位的光有 $0.4$ 单位穿过第 $2$ 层玻璃，有 $0.025$ 单位的光被反射回去。这 $0.025$ 单位的光有 $0.0125$ 单位穿过第 $1$ 层玻璃，有 $0.005$ 单位的光被反射回去。这 $0.005$ 单位的光有 $0.004$ 单位穿过第 $2$ 层玻璃……于是，穿过两层玻璃的光一共有$0.40404... = 40/99$ 单位。在模 $10^9+7$ 意义下等于 $858585865$。 

**数据范围：**  
对于 $5\%$ 的数据，$n=1$；    
对于 $20\%$ 的数据，$n\le 2$；    
对于 $30\%$ 的数据，$n\le 3$；    
对于 $50\%$ 的数据，$n\le 100$；    
对于 $70\%$ 的数据，$n\le 3000$；    
对于 $100\%$ 的数据，$n\le 5\times 10^5$，$1\le a_i \le 100$，$0\le b_i \le 99$，$1\le a_i+b_i \le 100$。  

每组 $a_i$ 和 $b_i$ 在满足上述限制的整数中随机生成。

# 题解 | 玻璃叠层透过率（几何级数 + 模运算）

## 问题重述

有 $n$ 层玻璃，第 $i$ 层单次“尝试”时：

- 透过比例 $a_i\%$
- 反射比例 $b_i\%$
- 吸收比例 $1-a_i-b_i\%$

一束强度为 1 的光从左到右入射到第一层。多次在层间来回反射后，**最终穿出最右侧**的光强是多少？输出结果对 $p=10^9+7$ 取模。
## 思路

**坑点**：叠起来的玻璃“从左入射时的反射率”和“从右入射时的反射率”**不一样**。  
为正确处理“在相邻两块之间来回反射”的次数，我们**必须**同时维护两个量：

- $P_i$：前 $i$ 层按顺序叠好后，**从左入射**最终穿出右侧的总透过率。
- $Q_i$：前 $i$ 层按顺序叠好后，**从右入射**最终被反回右侧的总反射率。

初值：

$$P_0 = 1,\qquad Q_0 = 0.$$

记 $L$ 为前 $i-1$ 层的组合块，$R$ 为第 $R$ 层单块。  

$$T_L = P_{i-1},\quad R_L^{(\text{from right})}=Q_{i-1};\qquad T_R = a_i,\quad R_R = b_i.$$
$T$ 表示该层透过率，$R$ 表示该层反射率。下标表示从何处入射。
---

## 推导

### 1) 推 $P_i$​（从左入射求总透过）

光要穿出整个 $L\!+\!R$，必须先穿过 $L$（权重 $P_{i-1}$​），然后在 $R$ 处“多次尝试直到成功穿出右侧”。

- 0 次失败后成功：权重 $a_i$。
- 1 次失败（在 $R$ 被反回 $b_i$​）→ 到 $L$ 的右侧，被 $L$ 从右侧反回 $Q_{i-1}​$ → 再回到 $R$ 再试 → 成功：$(Q_{i-1}b_i)\cdot a_i​$。
- 2 次失败后成功：$(Q_{i-1}b_i)^2\cdot a_i$。
- ……

把所有“失败 $k$ 次后成功”的路径求和（几何级数）：

$$P_i = P_{i-1}\cdot a_i\sum_{k=0}^{\infty}(Q_{i-1}b_i)^k = \frac{P_{i-1}\,a_i}{1-Q_{i-1}b_i}.$$

> 这就是为什么要“乘以反射率求和的级数”：它恰好统计了“在 $L$ 与 $R$ 之间往返 $k$ 轮后才成功穿越”的所有路径权重。

### 2) 推 $Q_i$​（从右入射求总反射回右侧）

从右入射先遇到 $R$，被反回右侧有两类路径：
- 立刻在 $R$ 反回：权重 $b_i$​。
- 穿过 $R$ 进入 $L$ → 在 $L$ 内部从右侧被反回右侧（权重 $Q_{i-1}$​）→ 再穿回 $R$ 出到右侧（再乘 $a_i$）。  
同时，在最终穿回前，可能在 $R$ 与 $L$ 间经历若干轮来回，每轮权重仍为 $Q_{i-1}b_i​$。总和：

$$a_i\cdot Q_{i-1}\cdot a_i \sum_{k=0}^{\infty}(Q_{i-1}b_i)^k = \frac{Q_{i-1}a_i^2}{1-Q_{i-1}b_i}.$$

于是

$$Q_i = b_i + \frac{Q_{i-1}a_i^2}{1-Q_{i-1}b_i}.$$

> 实数域里 $0\le b_i\le 0.99$，且 $0\le Q_{i-1}\le 1$，故 $|Q_{i-1}b_i|<1$，几何级数收敛，分母 $1-Q_{i-1}b_i\neq 0$。

---
- 总复杂度：$O\!\left(n\log p\right)$，$n\le 5\times 10^5$ 可轻松通过。
## Code

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
  

int qpow(int a, int b, int mod){
    int res = 1;
    while(b){
        if(b & 1) res = res * a % mod;
        a = a * a % mod, b >>= 1;
    }
    return res;
}

signed main(){
    int p = 1, q = 0;
    int inv = qpow(100ll, mod - 2, mod);
    int t; cin >> t;
    while(t--){
        int a, b; cin >> a >> b;
        a = a * inv % mod, b = b * inv % mod;
        int den = (1ll - q * b % mod + mod) % mod;
        p = (p * a % mod * qpow(den, mod - 2, mod)) % mod;
        q = (b + (q * a % mod * a % mod) * qpow(den, mod - 2, mod) % mod) % mod;
    }
    cout << p << '\n';
    return 0;
}
```