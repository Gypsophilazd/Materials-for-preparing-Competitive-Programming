## 题意概述

  在传统汉诺塔游戏的基础上，引入操作优先级的概念。即移动碟子必须根据输入给定的顺序，如果可以移动，必须移动当前碟子到指定位置。不可连续移动一个碟子 $2$ 次。求最后移动步数总和。

## Solution

采用分类讨论建立状态转移方程，以动态规划的方法解题。

首先我们知道对于传统的汉诺塔游戏，转移方程如下：

$$f(n) = 2\times f(n-1) +1$$

  观察本题的优先级顺序，又因为汉诺塔游戏只有三根柱子，不难发现所有的优先级顺序无非分为三种，我们可以通过类比的方式建立状态转移方程，将问题规模缩小为 $n=2$ 的情况进行推广。我们设：

$$dp[n] = x\times dp[n - 1] + y$$

移动顺序存在限制，除了最小的碟子以外，所有碟子都会被自己小的碟子限制（因为你不可能连续移动同一个碟子两次）。*也就是说，当前一定会搬运最小的碟子。*

故：

**$x$ 表示两次第 $i$ 个碟子移动之间，最小碟子需要走多少步。**

**$y$ 表示从刚放完第 $i-1$ 个碟子（或开始状态）到第 $i$ 个碟子第一次可以动，中间最小碟子要先走几步。**

本题解将 $n = 2$ 时进行推广（作为对其他题解的补充，即 $x$ 与 $y$ 如何得出），从而给出状态转移方程。各种情况也可视作最小碟子的循环模式。


先给总的状态转移方程：
$$n=1,dp[1]=1$$

$$
\begin{aligned}
dp[i] &=
\begin{cases}
2\times dp[i-1] + 1, & A \to B/C \to C/B \to A \\[4pt]
3\times dp[i-1] + 2, & A \to B/C \to A \\[4pt]
3\times dp[i-1],& A \to B/C \to C/B \to B/C
\end{cases}
\end{aligned}
$$

不难得出，时间复杂度为 $O(n)$。


### Case1：$A \to B/C \to A$

$n = 2$ 时，实际步骤如下：

对于 $y$，开始到第一次大碟子移动前，小碟子先走两步：$A\to B,B \to A$，这时 $A$ 再次空出，第一次大碟子才能 $A \to C$。

故 $y = 2$。

对于 $x$，两次大碟子移动之间，小碟子要在 $A，B$ 来回三步：$A\to B, B \to A, A \to B$，第三步走完后，再给第二次腾路机会。

故 $x = 3$。

$$dp[2]=3\times dp[1]+2=3\times 1+2=5$$

扩展到 $n$ 个碟子，那么 $x = 3, y = 2$ 很简单的道理，把第 $n$ 个碟子看做是最小的，其他 $n-1$ 个碟子看做是第二大的。故：

$$dp[n]=3\times dp[n-1]+2$$

### Case2：$A \to B/C \to C/B \to A$

$n = 2$ 时，实际步骤如下：

对于 $y$，开始到第一次大碟子移动前，小碟子第一步：$A \to B$，此时 $A$ 空出，第一次大碟子才能 $A \to C$。

故 $y = 1$。

对于 $x$，第一次大碟子移动到第二次大碟子移动之间，小碟子继续按循环走两步：$B \to C,C \to A$ 在 $C \to A$ 结束后，又给到了第二次腾路机会。

故 $x = 2$。

$$dp[2]=2\times dp[1]+1=2\times 1+1=3$$

同理可得：

$$dp[i]=2\times dp[i−1]+1$$

### Case3：$A \to B/C \to C/B \to B/C$

$n = 2$ 时，实际步骤如下：

对于 $y$，开始到第一次大碟子移动前，这条循环天然保证 $A\to B\to C$ 之间随时有空位放大碟子，第一次大碟子移动可在零步后直接进行。

故 $y = 0$。

对于$x$：两次大碟子移动之间，小碟子按：$A\to B,B\to C,C\to B$ 共三步，每一圈都刚好覆盖三根柱子，给出下一次腾路。

故 $x = 3$。

$$
dp[2]=3\times dp[1]+0=3\times 1+0=3
$$

即：

$$
dp[i]=3\times dp[i−1]+0
$$


## Code

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 105;
int dp[N];

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int n, x = 0, y = 0;

    while(cin >> n){
        string s; int op[4] = {0};
        for(int i = 0; i < 6; ++i){
            cin >> s;
            int a = s[0] - 'A' + 1, b = s[1] - 'A' + 1; // a出发柱子 b目标柱子
            if(op[a]) continue; // 已经有限制就跳过
            op[a] = b;
        }
        if(op[2] != 1 && op[3] != 1) x = 3, y = 0;
        else if(op[op[1]] == 1) x = 3, y = 2;
        else x = 2, y = 1;

        dp[1] = 1;
        for(int i = 2; i <= n; ++i) dp[i] = dp[i - 1] * x + y;
        cout << dp[n] << '\n';
    }
    return 0;
}



```
注：本题解也可视作是对于已有题解的补充，思维难度较高。