### 一、概述与原理
1. BFS是一种按层次遍历的算法,以起点为中心逐层向外扩散搜索,**保证首次访问到目标节点节点的路径是最短路径(边权相等)**.
2. 一般使用queue(队列)进行操作,适用于无权图最短路,层次遍历与连通性问题
### 模版
```
struct Node....(按需要填写)
vis[N] = {false};
void bfs(int st){
	queue<Node> q;
	q.push(st);
	vis[st] = true;
	for(int i = 0; i < q.size(); ++i){
		auto cur = q.front(); q.pop();
		if(cur = target) return res;
		for(auto &i : cur.neighbors){
			if(!vis[i]) q.push(i);
			vis[i] = true;
		}
	}
}

```

- **队列（FIFO）**：保证先进先出，按层级顺序处理节点。
- **访问标记**：避免重复访问和循环。

---

### 二、BFS与DFS的本质区别

#### 1. **数据结构与搜索方式**

| **特性** | BFS              | DFS             |
| ------ | ---------------- | --------------- |
| 数据结构   | 队列（Queue）        | 栈（Stack，递归隐式使用） |
| 搜索顺序   | 层序扩展（横向搜索）       | 深度优先（纵向搜索）      |
| 空间复杂度  | O(bd)（b分支因子，d深度） | O(d)            |
| 最短路径保证 | 是（无权图）           | 否（需穷举所有路径）      |
#### 2. **典型应用场景对比**

##### **BFS适用场景**

- **最短路径问题**：如迷宫最短路径、社交网络最少中间人。
- **层次遍历**：树/图的层级分析（如二叉树层序遍历）。
- **广播模型**：信息从起点扩散到全图的场景（如病毒传播模拟）。
- **连通性检测**：判断图中所有节点是否可达。

##### **DFS适用场景**

- **路径存在性判断**：仅需确认是否存在路径（如迷宫是否有解）。
- **回溯问题**：排列组合、子集生成（需穷举所有可能）。
- **拓扑排序**：有向无环图的依赖解析。
- **复杂图分析**：强连通分量、环路检测。

---

### 三、BFS的优化与变种

#### 1. **双向BFS（Bidirectional BFS）**

- **原理**：从起点和终点同时开始BFS，当两向搜索相遇时终止。
- **优势**：时间空间复杂度降至 O(bd/2)O(bd/2)，适合大规模数据。
- **适用场景**：明确知道目标状态的搜索（如单词接龙问题）。

#### 2. **多源BFS（Multi-source BFS）**

- **原理**：初始队列包含多个起点，同时扩散（如多个火源蔓延模型）。
- **代码修改**：初始化时将多个起点加入队列并标记访问。
- **应用**：矩阵中所有黑点到最近白点的距离（LeetCode 542）。

#### 3. **优先级队列BFS（Dijkstra算法）**

- **原理**：队列按优先级排序，解决带权图最短路径问题。
- **实现**：使用优先队列（最小堆），每次取出当前最短路径节点。

https://www.luogu.com.cn/problem/P2335
[[Luogu P2335 SDOI2005 位图]]

