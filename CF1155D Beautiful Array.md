## 题目描述

NaCly_Fish 给了你一个长度为 $n$ 的序列。

她想知道这个序列最大的美丽程度。

同时，她给了你一次操作的机会，你需要选择序列的一个子串，将其中所有数乘上 NaCly_Fish 给定的一个常数 $x$。

我们定义一个序列的美丽程度为其所有子串的和的最大值，而子串则是序列的一个连续子序列，在本题中，子串可以是空的。

## 输入格式

第一行包括了两个整数 $n,x$，满足 $1\le n\le3\times10^5$，且$-100\le x\le100$。

之后一行包括了 $n$ 个整数 $a_i$，表示题中所给的序列，满足 $-10^9\le a_i\le10^9$。

## 输出格式

输出一行一个整数，表示这个序列进行操作后的美丽程度。

## 输入输出样例 #1

### 输入 #1

```
5 -2
-3 8 -2 1 -6
```

### 输出 #1

```
22
```

## 输入输出样例 #2

### 输入 #2

```
12 -3
1 3 3 7 1 3 3 7 1 3 3 7
```

### 输出 #2

```
42
```

## 输入输出样例 #3

### 输入 #3

```
5 10
-1 -2 -3 -4 -5
```

### 输出 #3

```
0
```

## Solution

最大子串和的变种，可想而知要使用 DP 解决。

建模的第一步是定义状态：定义 `dp[x][3]` 表示到第 $x$ 位的最大子串和。对应三个阶段可以如下表示。

- **阶段 0 (前缀段)**: 子串中完全没有乘以 x 的部分。
    
- **阶段 1 (核心段)**: 子串中正在进行乘以 x 操作的部分。
    
- **阶段 2 (后缀段)**: 子串中乘以 x 的部分已经结束，后面又接上了一段普通数字。

状态转移方程的解读是这样的：

 `dp[i][0] = max(dp[i - 1][0] + a[i], 0ll);` 这里的 `0ll` 意味着如果加上 `a[i]` 会使和变为负数，我们宁愿从当前位置重新开始一个新的子串（或者视为空子串，和为0）
 
 `dp[i][1] = max(dp[i][0], dp[i - 1][1] + a[i] * x);`对应的情况是，我们**延续**了前一个 `*x` 的状态。也就是说，`a[i-1]` 也在乘以 x 的子串里，现在 `a[i]` 也加入这个子串，并与 `dp[i][0]` 作对比。
 
`dp[i][2] = max(dp[i][1], dp[i - 1][2] + a[i]);`表示处理到第 `i` 个元素时，以 `a[i]` **结尾** 的，并且其**内部已经包含过**一个完整的 `*x` 子串的最大子串和。

状态转移方程保证转移形式单向流动，所以可以保证不会拆分最大子串和。

## Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 3e5 + 5;
int a[N], dp[N][4];

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int n, x; cin >> n >> x;
    for(int i = 1; i <= n; ++i) cin >> a[i];
    int ans = 0;
    for(int i = 1; i <= n; ++i){
        dp[i][0] = max(dp[i - 1][0] + a[i], 0ll);
        dp[i][1] = max(dp[i][0], dp[i - 1][1] + a[i] * x);
        dp[i][2] = max(dp[i][1], dp[i - 1][2] + a[i]);
        ans = max(ans, dp[i][2]);
    }
    cout << ans << endl;
    return 0;
}
```